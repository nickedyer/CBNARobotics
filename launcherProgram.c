#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           conveyor,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           flywheel,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           ballLift,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**************************************************************************/
/*	Nicholas Dyer																													*/
/*	CBNA Robotics 2018-2019																								*/
/*	Launcher Program Version 0.5																					*/
/*	Last Worked 11/30/2018																								*/
/**************************************************************************/

//Set Constants
int deadzoneValue = 20;
float fRDegree = (45*3.14159265358979)/180;
float fLDegree = (135*3.14159265358979)/180;
float bLDegree = (225*3.14159265358979)/180;
float bRDegree = (315*3.14159265358979)/180;

//Define Controller Variables
int rightBumpUp;
int rightBumpDown;
int leftBumpUp;
int leftBumpDown;
int leftUp;
int leftDown;
int leftLeft;
int leftRight;
float joyLeftX;
float joyLeftY;
float joyRightX;
float joyRightY;

//Define Motor Value Variables
int flyValue;
int leftDriveValue;
int rightDriveValue;
int conveyorValue;
int fLDrive;
int fRDrive;
int bLDrive;
int bRDrive;

//Define Motor Angle Variables
float phi;
float rValue;

void pre_auton()
{
  bStopTasksBetweenModes = true; //Reset Tasks between competition switch
}

void handleControl()
{
	//Set Controller Values to Variables
	rightBumpUp = vexRT[Btn6U];
	rightBumpDown = vexRT[Btn6D];
	leftBumpUp = vexRT[Btn5U];
	leftBumpDown = vexRT[Btn5D];

	leftUp = vexRT[Btn7U];
	leftDown = vexRT[Btn7D];
	leftLeft = vexRT[Btn7L];
	leftRight = vexRT[Btn7R];

	joyLeftX = vexRT[Ch4];
	joyLeftY = vexRT[Ch3];
	joyRightX = vexRT[Ch1];
	joyRightY = vexRT[Ch2];

	//Check Deadzones
	if (abs(joyLeftX) < deadzoneValue) //If the joystick is registering lower than the deadzone value
	{
		joyLeftX = 0; //Set the joystick variable to 0
	}
	if (abs(joyLeftY) < deadzoneValue)
	{
		joyLeftY = 0;
	}
	if (abs(joyRightX) < deadzoneValue)
	{
		joyRightX = 0;
	}
	if (abs(joyRightY) < deadzoneValue)
	{
		joyRightY = 0;
	}
}

void handleTranslate()
{
	//Set Up Variables for Polar Coordinates
	phi = atan2(joyRightY, joyRightX);
	rValue = sqrt((joyRightX*joyRightX)+(joyRightY*joyRightY));

	//Set the Value of the Motors
	fRDrive = sin(fRDegree-phi)*rValue;
	fLDrive = sin(fLDegree-phi)*rValue;
	bRDrive = sin(bRDegree-phi)*rValue;
	bLDrive = sin(bLDegree-phi)*rValue;
}

void handleRotate() //Handle Rotating the Robot
{
	if (joyLeftX != 0)
	{
		fRDrive = -joyLeftX;
		fLDrive = -joyLeftX;
		bRDrive = -joyLeftX;
		bLDrive = -joyLeftX;
	}
}

void handleFlywheel() //Flywheel Control
{
	if (leftUp == 1)
	{
		flyValue = 127; //If the left up button is pressed, set flywheel to max speed
	}
	if (leftDown == 1)
	{
		flyValue = 0; //If the left down button is pressed, turn the flywheel off
	}
	if (leftLeft == 1 && time1[T1] > 500)	//If the left left button is pressed
	{																			//and has not been pressed in the
		flyValue = flyValue-22;							//last 30 milliseconds, decrease the flywheel
		clearTimer(T1);											//speed by 32.
	}
	if (leftRight == 1 && time1[T1] > 500)//If the left right button is pressed
	{																			//and has not been pressed in the
		flyValue = flyValue+22;							//last 30 milliseconds, increase the flywheel
		clearTimer(T1);											//speed by 32.
	}
	if (flyValue < 0) //If the flywheel value is set below zero, force the value to zero.
	{
		flyValue = 0;
	}
	if (flyValue > 127) //If the flywheel value is set above 127, force the value to 127.
	{
		flyValue = 127;
	}
}

void handleMotor() //Set motors to their values
{
	motor[conveyor] = conveyorValue;
	motor[flywheel] = flyValue;
	motor[frontLeft] = fLDrive;
	motor[frontRight] = fRDrive;
	motor[backLeft] = bLDrive;
	motor[backRight] = bRDrive;
}

task autonomous() //Autonomous Mode
{
  flyValue = 127;
  handleMotor();
  sleep(2000); //Turn the flywheel on and wait 2 seconds
  leftDriveValue = 127;
  rightDriveValue = 127;
  handleMotor();
  sleep(850); //Drive forward for 0.85 seconds
  leftDriveValue = 0;
  rightDriveValue = 0;
  conveyorValue = 127;
  handleMotor();
  sleep(5000); //Stop and turn on the conveyor for 5 seconds
  conveyorValue = 0;
  flyValue = 0;
  leftDriveValue = 110;
  rightDriveValue = 127;
  handleMotor();
  sleep(1500); //Turn off the flywheel and conveyor and drive slightly left
  leftDriveValue = 0;
  rightDriveValue = 0;
  handleMotor(); //Stop
}

task usercontrol() //User Control Mode
{
  while (true) //Main Loop
  {
  	handleControl();
  	handleTranslate();
  	handleRotate();
		handleFlywheel();
		handleMotor();
  }
}
